% run the command ' lualatex -shell-escape Reference.tex ' twice in the terminal to visualize table of contents
\documentclass[twoside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{geometry}
\usepackage{multicol}
\usepackage{minted}
\usepackage{python}
\usepackage{fontspec}
\usepackage[hidelinks]{hyperref}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{pdfpages}
\usepackage{needspace}
\usepackage{sectsty}
\usepackage{array}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{xcolor}
\usepackage{afterpage}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{svg}
\usepackage[inline]{enumitem}

\graphicspath{ {./media/} }

\definecolor{prussianblue}{rgb}{0.0, 0.19, 0.33}
\definecolor{indigo(dye)}{rgb}{0.0, 0.25, 0.42}
\definecolor{lapislazuli}{rgb}{0.15, 0.38, 0.61}
\definecolor{mediumelectricblue}{rgb}{0.01, 0.31, 0.59}
\definecolor{smalt(darkpowderblue)}{rgb}{0.0, 0.2, 0.6}
\definecolor{yaleblue}{rgb}{0.06, 0.3, 0.57}
\definecolor{skobeloff}{rgb}{0.0, 0.48, 0.45}
\definecolor{pinegreen}{rgb}{0.0, 0.47, 0.44}
\definecolor{coolgray}{RGB}{49, 63, 71}
\definecolor{coolpink}{RGB}{255,116,150}

\setmainfont[
    BoldFont=nexabold.ttf
]{nexalight.ttf}

\setsansfont[
    BoldFont=nexabold.ttf
]{nexalight.ttf}

\geometry{letterpaper, landscape, left=0.5cm, right=0.5cm, top=1.8cm, bottom=1cm}

\sectionfont{\Huge\bfseries\sffamily}

\setminted{
    style=manni,
    breaklines=true,
    breakanywhere=true,
    tabsize=4
}

\setlength{\color{coolpink}\headsep}{0.5cm}
\setlength{\columnsep}{0.5cm}
\setlength{\columnseprule}{0.1cm}
\renewcommand{\columnseprulecolor}{\color{coolpink}}


\pagenumbering{arabic}
\fancyhead{}
\fancyfoot{}
\fancyhead[LO,RE]{\textcolor{coolgray}{Enya Quetzalli Gómez Rodríguez}}
\fancyhead[LE,RO]{\textcolor{coolgray}{\leftmark}}
\fancyfoot[LE,RO]{\textcolor{coolgray}{\textbf{\thepage}}}

\renewcommand{\headrulewidth}{0.05cm}
\renewcommand{\footrulewidth}{0.01cm}
\newcommand\YUGE{\fontsize{35}{50}\selectfont}

\setlength{\parindent}{0em}
% column space
\setlength{\tabcolsep}{10pt} % Default value: 6pt
% upper and lower padding
\renewcommand{\arraystretch}{1.5} % Default value: 1

\begin{document}

    \pagecolor{coolgray}
    \vspace*{\fill}
        \textcolor{coolpink}{\centerline{\YUGE\textbf{Competitive Programming Reference}}}
        
        \noindent
        \vskip5mm
        \centerline{{\color{coolpink} \rule{200 mm}{1 mm} }}
        \vskip5mm
        
        \textcolor{coolpink}{\centerline{\Huge{Enya Quetzalli Gómez Rodríguez}}}
        
        \vskip35mm
        
        \textcolor{coolpink}{\centerline{\large{eithnegomez@hotmail.com}}}
        \textcolor{coolpink}{\centerline{\large{github.com/equetzal}}}
    \vfill
    
    \newpage
    \pagecolor{white}
    \thispagestyle{empty}
    \null
    \newpage
    
    \pagestyle{fancy}
    \newpage
    

\selectfont
    \color{coolgray}
        \begin{multicols*}{2}
\tableofcontents
\newpage
\needspace{22\baselineskip}
\sectionfont{\bfseries\sffamily\centering\Huge}
\vspace{1em}
\section*{Data Structures}
\markboth{DATA STRUCTURES}{}
\addcontentsline{toc}{section}{Data Structures}
\vspace{3em}
\subsectionfont{\bfseries\sffamily\centering\LARGE}
\vspace{0em}
\subsection*{STL}
\addcontentsline{toc}{subsection}{STL}
\vspace{2em}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{STL Map}
\addcontentsline{toc}{subsubsection}{STL Map}
\begin{minted}{cpp}
#include <map>

map<int,string> m,p;
map<pair<int,int>,string> mpii;
m[111] = "val"; //Insert, or replace element in map
auto val = m[111]; //Return element with key 111, if no key create key with default val
m.erase(111); //Erase element with key 111
m.merge(p); //Insert or replace p elements into s in O(|S|log(|P|+|S|))
int val = s.count(111); //Return number of elements in map with key 111
set<map>::iterator it = s.find(111); //Return m.end() if not found, or map iterator if found
auto it = m.lower_bound(111); //Return first not-less element than key in O(logN)
auto it = m.upper_bound(111); //Return first element greater than key in O(logN)
s.swap(p); //Swap map contents in O(1)

\end{minted}

\needspace{18\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{STL Multi Map}
\addcontentsline{toc}{subsubsection}{STL Multi Map}
\begin{minted}{cpp}
#include <multimap>

multimap<string,string> m;
m.emplace("key","val"); //Insert element in multimap
m.erase(it); //Erase element at iterator = it
m.erase(itBegin, itEnd); //Erase elements in range from itBegin to itEnd
m.erase("key"); //Erase all elements with key
m.clear(); //Erase all elements in multimap
int val = m.count("key"); //Return number of elements with key

//To get elements with same key
auto range = m.equal_range("key"); //Return a pair of begin-end iterators which holds elements equal to key
cout << "for key[key] -> ";
for(auto it=range.first; it!=range.end; it++)
	cout << (*it).second << " ";
cout << endl;

\end{minted}

\needspace{18\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{STL Multi Set}
\addcontentsline{toc}{subsubsection}{STL Multi Set}
\begin{minted}{cpp}
#include <multiset>

//multiset is the same as set, but s.count() can be more than 1
set<int> s,p;
set<pair<int,int>> spii;
s.insert(int(111)); //Insert value in vector
spii.insert(make_pair(11,22));
s.emplace(111); //Insert but with constructor
spii.emplace(11,22);
s.erase(111); //Erase element with value 111
s.merge(p); //Insert p elements into s in O(|S|log(|P|+|S|))
int val = s.count(111); //Return number insertions-erations in set with value 111
set<int>::iterator it = s.find(111); //Return s.end() if not found, or set iterator if found
auto it = s.lower_bound(111); //Return first not-less element than arg in O(logN)
auto it = s.upper_bound(111); //Return first element greater than arg in O(logN)
s.swap(p); //Swap set contents in O(1)

\end{minted}

\needspace{17\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{STL Queue}
\addcontentsline{toc}{subsubsection}{STL Queue}
\begin{minted}{cpp}
#include <queue>

queue<int> q,p;
queue<pair<int,int>> qpii;
q.push(int(111)); //Receives an object copy
qpii.push(make_pair(11,22);
q.emplace(111); //Uses the constructor of the object
qpii.emplace(11,22);
int val = q.front(); //Acces head element
int val = q.back(); //Access tail element
int sz = q.size();
q.pop();
q.empty();
q.swap(p); //Swap queue contents in O(1)
q.clear(); //Erase elements of queue

\end{minted}

\needspace{17\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{STL Set}
\addcontentsline{toc}{subsubsection}{STL Set}
\begin{minted}{cpp}
#include <set>

set<int> s,p;
set<pair<int,int>> spii;
s.insert(int(111)); //Insert value in vector
spii.insert(make_pair(11,22));
s.emplace(111); //Insert but with constructor
spii.emplace(11,22);
s.erase(111); //Erase element with value 111
s.merge(p); //Insert p elements into s in O(|S|log(|P|+|S|))
int val = s.count(111); //Return number of elements in set with value 111
set<int>::iterator it = s.find(111); //Return s.end() if not found, or set iterator if found
auto it = s.lower_bound(111); //Return first not-less element than arg in O(logN)
auto it = s.upper_bound(111); //Return first element greater than arg in O(logN)
s.swap(p); //Swap set contents in O(1)

\end{minted}

\needspace{16\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{STL Stack}
\addcontentsline{toc}{subsubsection}{STL Stack}
\begin{minted}{cpp}
#include <stack>

stack<int> s,p;
stack<pair<int,int>> spii;
s.push(int(111)); //Receives an object copy
spii.push(make_pair(11,22));
s.emplace(111); //Uses the constructor of the object
spii.emplace(11,22);
int val = s.top(); //Return value of element at tio
int val = s.size(); //Return number of elements in stack
s.pop(); //Erase the element at the top of stack
bool val = s.empty(); //Return true if stack is empty
s.swap(p); //Swap stack contents in O(1)
s.clear() //Erase elements of stack

\end{minted}

\needspace{21\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{STL Vector}
\addcontentsline{toc}{subsubsection}{STL Vector}
\begin{minted}{cpp}
#include <vector>

vector<int> v,p;
vector<pair<int,int>> vpii;
v.push_back(int(111)); //Insert value at end of vector
v.pop_back(); //Erase the element at end of vector
int val = v.back(); //Return value at end of vector
int val = v.front(); //Return value at begin of vector
v.insert(v.begin()+pos, int(111); //Insert element before pos in O(pos)
vpii.insert(v.begin()+pos, make_pair(11,22));
v.emplace(v.begin()+pos, 111); //Insert, but uses constructor after pos arg
vpii.emplace(v.begin()+pos, 11,22);
v.erase(v.begin()+pos); //Erase element at pos in O(n)
v.clear(); //Clear the contents of a vector O(n)
int val = v.size(); //Return size of vector -> cast size_t to int
bool val = v.emtpy(); //Return true if vector is empty
v.resize(5); //If arg is smaller than size, it cuts the vector, if not, expand array with default init
v.resize(5,0); //If arg si larger than size, init values with 2nd arg
v.swap(p); //Swap vector contents in O(1)

\end{minted}

\needspace{7\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{Unordered Map Key=Pair}
\addcontentsline{toc}{subsubsection}{Unordered Map Key=Pair}
\begin{minted}{cpp}
struct pairhash { template <class T1, class T2>
	size_t operator()(const pair<T1, T2> &p) const {
		return hash<T1>{}(p.first) ^ (hash<T2>{}(p.second) << 32);
	}
};
\end{minted}
\vspace{-12pt}
\needspace{1\baselineskip}
\begin{minted}{cpp}
unordered_map<pair<int, int>, int, hash_pair> umap;

\end{minted}

\needspace{14\baselineskip}
\sectionfont{\bfseries\sffamily\centering\Huge}
\vspace{1em}
\section*{Math}
\markboth{MATH}{}
\addcontentsline{toc}{section}{Math}
\vspace{3em}
\subsectionfont{\bfseries\sffamily\centering\LARGE}
\vspace{0em}
\subsection*{Number Theory}
\addcontentsline{toc}{subsection}{Number Theory}
\vspace{2em}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{Greatest Common Divisor}
\addcontentsline{toc}{subsubsection}{Greatest Common Divisor}
\begin{minted}{cpp}
lli gcd(lli a, lli b){
	lli r;
	while(b != 0) r = a % b, a = b, b = r;
	return a;
}

\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
lli gcd(vector<lli> & nums){
	lli ans = 0;
	for(lli & num : nums) ans = gcd(ans, num);
	return ans;
}

\end{minted}
\vspace{-12pt}
\needspace{11\baselineskip}
\begin{minted}{cpp}
lli extendedGcd(lli a, lli b, lli & s, lli & t){
	lli q, r0 = a, r1 = b, ri, s0 = 1, s1 = 0, si, t0 = 0, t1 = 1, ti;
	while(r1){
		q = r0 / r1;
		ri = r0 % r1, r0 = r1, r1 = ri;
		si = s0 - s1 * q, s0 = s1, s1 = si;
		ti = t0 - t1 * q, t0 = t1, t1 = ti;
	}
	s = s0, t = t0;
	return r0;
}

\end{minted}

\needspace{5\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{Lowest Common Multiple}
\addcontentsline{toc}{subsubsection}{Lowest Common Multiple}
\begin{minted}{cpp}
lli lcm(lli a, lli b){
	return b * (a / gcd(a, b));
}

\end{minted}
\vspace{-12pt}
\needspace{5\baselineskip}
\begin{minted}{cpp}
lli lcm(vector<lli> & nums){
	lli ans = 1;
	for(lli & num : nums) ans = lcm(ans, num);
	return ans;
}

\end{minted}

\needspace{12\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{Modular Inverse}
\addcontentsline{toc}{subsubsection}{Modular Inverse}
\begin{minted}{cpp}
lli modularInverse(lli a, lli m){
	lli r0 = a, r1 = m, ri, s0 = 1, s1 = 0, si;
	while(r1){
		si = s0 - s1 * (r0 / r1), s0 = s1, s1 = si;
		ri = r0 % r1, r0 = r1, r1 = ri;
	}
	if(r0 < 0) s0 *= -1;
	if(s0 < 0) s0 += m;
	return s0;
}

\end{minted}

\needspace{16\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{Multiplication}
\addcontentsline{toc}{subsubsection}{Multiplication}
\begin{minted}{cpp}
lli multMod(lli a, lli b, lli n){
	lli ans = 0;
	a %= n, b %= n;
	if(abs(b) > abs(a)) swap(a, b);
	if(b < 0){
		a *= -1, b *= -1;
	}
	while(b){
		if(b & 1) ans = (ans + a) % n;
		b >>= 1;
		a = (a + a) % n;
	}
	return ans;
}

\end{minted}

\needspace{13\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{Number Base}
\addcontentsline{toc}{subsubsection}{Number Base}
\begin{minted}{cpp}
string decimalToBaseB(lli n, lli b){
	string ans = "";
	lli d;
	do{
		d = n % b;
		if(0 <= d && d <= 9) ans = (char)(48 + d) + ans;
		else if(10 <= d && d <= 35) ans = (char)(55 + d) + ans;
		n /= b;
	}while(n != 0);
	return ans;
}

\end{minted}
\vspace{-12pt}
\needspace{9\baselineskip}
\begin{minted}{cpp}
lli baseBtoDecimal(const string & n, lli b){
	lli ans = 0;
	for(const char & d : n){
		if(48 <= d && d <= 57) ans = ans * b + (d - 48);
		else if(65 <= d && d <= 90) ans = ans * b + (d - 55);
		else if(97 <= d && d <= 122) ans = ans * b + (d - 87);
	}
	return ans;
}

\end{minted}

\needspace{11\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{Power}
\addcontentsline{toc}{subsubsection}{Power}
\begin{minted}{cpp}
lli power(lli b, lli e){
	lli ans = 1;
	while(e){
		if(e & 1) ans *= b;
		e >>= 1;
		b *= b;
	}
	return ans;
}

\end{minted}
\vspace{-12pt}
\needspace{14\baselineskip}
\begin{minted}{cpp}
lli powerMod(lli b, lli e, lli m){
	lli ans = 1;
	b %= m;
	if(e < 0){
		b = modularInverse(b, m);
		e *= -1;
	}
	while(e){
		if(e & 1) ans = (ans * b) % m;
		e >>= 1;
		b = (b * b) % m;
	}
	return ans;
}

\end{minted}

\needspace{7\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{Random Number}
\addcontentsline{toc}{subsubsection}{Random Number}
\begin{minted}{cpp}
mt19937_64 rng(chrono::steady_clock::now().time_since_epoch().count());
lli aleatorio(lli a, lli b){
	std::uniform_int_distribution<lli> dist(a, b);
	return dist(rng);
}

\end{minted}

\needspace{34\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{Roman Numbers}
\addcontentsline{toc}{subsubsection}{Roman Numbers}
\begin{minted}{cpp}
string decimalToRoman(int n){
	int d, b = 0;
	string ans = "";
	vector<vector<char>> datos = {{'I', 'V'}, {'X', 'L'}, {'C', 'D'}, {'M', '\0'}};
	int miles = n / 1000;
	do{
		string tmp = "";
		d = n % 10;
		n /= 10;
		if(b < 3){
			if(0 <= d && d <= 3){
				tmp.append(d, datos[b][0]);
			}else if(d == 4){
				tmp += datos[b][0];
				tmp += datos[b][1];
			}else if(5 <= d && d <= 8){
				tmp += datos[b][1];
				tmp.append(d - 5, datos[b][0]);
			}else if(d == 9){
				tmp += datos[b][0];
				tmp += datos[b + 1][0];
			}
		}else{
			tmp.append(miles, 'M');
			ans = tmp + ans;
			break;
		}
		ans = tmp + ans;
		b++;
	}while(n != 0);
	return ans;
}

\end{minted}
\vspace{-12pt}
\needspace{21\baselineskip}
\begin{minted}{cpp}
int romanToDecimal(string n){
	int ans = 0;
	char curr, prev;
	bool f = false;
	map<char, int> datos = {{'I', 1}, {'V', 5}, {'X', 10}, {'L', 50}, {'C', 100}, {'D', 500}, {'M', 1000}};
	for(int i = n.size() - 1; i >= 0; i--){
		curr = n[i];
		if(i > 0) prev = n[i - 1];
		if(curr == 'V' && prev == 'I') ans += 4, f = true;
		else if(curr == 'X' && prev == 'I') ans += 9, f = true;
		else if(curr == 'L' && prev == 'X') ans += 40, f = true;
		else if(curr == 'C' && prev == 'X') ans += 90, f = true;
		else if(curr == 'D' && prev == 'C') ans += 400, f = true;
		else if(curr == 'M' && prev == 'C') ans += 900, f = true;
		else{
			if(!f) ans += datos[curr];
			f = false;
		}
	}
	return ans;
}

\end{minted}

\needspace{10\baselineskip}
\subsubsectionfont{\large\bfseries\sffamily\underline}
\subsubsection*{Rounding}
\addcontentsline{toc}{subsubsection}{Rounding}
\begin{minted}{cpp}
lli piso(lli a, lli b){
	if((a >= 0 && b > 0) || (a < 0 && b < 0)){
		return a / b;
	}else{
		if(a % b == 0) return a / b;
		else return a / b - 1;
	}
}

\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
lli techo(lli a, lli b){
	if((a >= 0 && b > 0) || (a < 0 && b < 0)){
		if(a % b == 0) return a / b;
		else return a / b + 1;
	}else{
		return a / b;
	}
}

\end{minted}

\needspace{36\baselineskip}
\sectionfont{\bfseries\sffamily\centering\Huge}
\vspace{1em}
\section*{Extras}
\markboth{EXTRAS}{}
\addcontentsline{toc}{section}{Extras}
\vspace{3em}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{Definitions}
\addcontentsline{toc}{subsection}{Definitions}
\begin{minted}{cpp}
#if defined(_USE_MATH_DEFINES) && !defined(_MATH_DEFINES_DEFINED)
#define _MATH_DEFINES_DEFINED
	// e
	#define M_E		2.71828182845904523536
	// log2(e)
	#define M_LOG2E		1.44269504088896340736
	// log10(e)
	#define M_LOG10E	0.434294481903251827651
	// ln(2)
	#define M_LN2		0.693147180559945309417
	// ln(10)
	#define M_LN10		2.30258509299404568402
	// pi
	#define M_PI		3.14159265358979323846
	// pi/2
	#define M_PI_2		1.57079632679489661923
	// pi/4
	#define M_PI_4		0.785398163397448309616
	// 1/pi
	#define M_1_PI	 	0.318309886183790671538
	// 2/pi
	#define M_2_PI		0.636619772367581343076
	// 2/sqrt(pi)
	#define M_2_SQRTPI	1.12837916709551257390
	// sqrt(2)
	#define M_SQRT2		1.41421356237309504880
	// 1/sqrt(2)
	#define M_SQRT1_2	0.707106781186547524401
#endif


\end{minted}

\needspace{10\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{Output Hacks}
\addcontentsline{toc}{subsection}{Output Hacks}
\begin{minted}{cpp}
double pi = 3.14159265359;
cout << pi << endl;
// "3.14159"
cout << setprecision(7) << pi << endl;
// "3.141593"
cout << fixed << setprecision(7) << pi << endl;
// "3.1415927"

\end{minted}
\vspace{-12pt}
\needspace{9\baselineskip}
\begin{minted}{cpp}
int v = 220;
cout << v << endl;
// "220"
cout << setw(6) << v << endl;
// "   220"
cout << setw(6) << setfill('0') << v << endl;
// "000220"
cout << setw(6) << setfill('0') << left << v << endl;
// "220000"

\end{minted}
\vspace{-12pt}
\needspace{8\baselineskip}
\begin{minted}{cpp}
cout << hex << v << endl;
// "dc" (hex lowercase print)
cout << uppercase << v << endl;
// "DC" (HEX uppercase print)
cout << oct << v << endl;
// "334" (Octal print)
cout << bitset<8>(v) << endl;
// "11011100" (N-bit Binary Unsigned Int print)

\end{minted}

\needspace{5\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{Read Data From Files}
\addcontentsline{toc}{subsection}{Read Data From Files}
\begin{minted}{cpp}
freopen("input.txt", "r", stdin);
freopen("output.txt", "w", stdout);

\end{minted}

\needspace{17\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{Template}
\addcontentsline{toc}{subsection}{Template}
\begin{minted}{cpp}
#include <bits/stdc++.h>

#define endl "\n"
#define fast_io ios_base::sync_with_stdio(false);cin.tie(NULL);

using namespace std;

typedef long long int lli;

int main(){


	return 0;
}
\end{minted}

\end{multicols*}

    
    \newpage
    \thispagestyle{empty}
    \textcolor{coolgray}{\centerline{\Huge\textbf{Competitive Programming Reference}}}
    \vskip5mm
    \textcolor{coolgray}{\centerline{\large{\textbf{Created by:} Enya Quetzalli Gómez Rodríguez}}}
    \vskip1mm
    \textcolor{coolgray}{\centerline{\large{\textbf{Created with:} mkcpr reference}}}
    \vskip1mm
    \textcolor{coolgray}{\centerline{\large{\textbf{Created on:} March 30, 2020}}}
    \vskip1mm
    \textcolor{coolgray}{\centerline{\large{\textbf{Last Update:} \today}}}
    \vskip10mm

    \begin{center}
        \textcolor{coolgray}{\center{\large{\textbf{I met the competitive programming at my university "The Superior School of Computer Sciences of the National Polytechnic Institute", thanks to a club within the school called "algorithmic club", where I met ICPC and loved competitive programming, this group of people at I belong has offered me everything I know now, we always pass all our knowledge to the following generations, and we all contribute to our community to achieve more and more. I will always be grateful to this group of people who changed my life}}}}
    \end{center}
    
    \vskip10mm
    
     \textcolor{coolgray}{\centerline{\large{\textbf{Special thanks:}}}}
     
     \centering
     \includegraphics[width=4cm, height=4cm]{logo_huron_circular}
     
     
\end{document}
