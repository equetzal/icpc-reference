% run the command ' lualatex -shell-escape Reference.tex ' twice in the terminal to visualize table of contents
\documentclass[twoside]{article}
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage{geometry}
\usepackage{multicol}
\usepackage{minted}
\usepackage{python}
\usepackage{fontspec}
\usepackage[hidelinks]{hyperref}
\usepackage{fancyhdr}
\usepackage{listings}
\usepackage{pdfpages}
\usepackage{needspace}
\usepackage{sectsty}
\usepackage{array}
\usepackage{multirow}
\usepackage{longtable}
\usepackage{xcolor}
\usepackage{afterpage}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{svg}
\usepackage[inline]{enumitem}

\graphicspath{ {./media/} }

\definecolor{prussianblue}{rgb}{0.0, 0.19, 0.33}
\definecolor{indigo(dye)}{rgb}{0.0, 0.25, 0.42}
\definecolor{lapislazuli}{rgb}{0.15, 0.38, 0.61}
\definecolor{mediumelectricblue}{rgb}{0.01, 0.31, 0.59}
\definecolor{smalt(darkpowderblue)}{rgb}{0.0, 0.2, 0.6}
\definecolor{yaleblue}{rgb}{0.06, 0.3, 0.57}
\definecolor{skobeloff}{rgb}{0.0, 0.48, 0.45}
\definecolor{pinegreen}{rgb}{0.0, 0.47, 0.44}
\definecolor{coolgray}{RGB}{49, 63, 71}
\definecolor{coolpink}{RGB}{255,116,150}

\setmainfont[
    BoldFont=nexabold.ttf
]{nexalight.ttf}

\setsansfont[
    BoldFont=nexabold.ttf
]{nexalight.ttf}

\geometry{letterpaper, landscape, left=0.5cm, right=0.5cm, top=1.8cm, bottom=1cm}

\sectionfont{\Huge\bfseries\sffamily}

\setminted{
    style=manni,
    breaklines=true,
    breakanywhere=true,
    tabsize=4
}

\setlength{\color{coolpink}\headsep}{0.5cm}
\setlength{\columnsep}{0.5cm}
\setlength{\columnseprule}{0.1cm}
\renewcommand{\columnseprulecolor}{\color{coolpink}}


\pagenumbering{arabic}
\fancyhead{}
\fancyfoot{}
\fancyhead[LO,RE]{\textcolor{coolgray}{Enya Quetzalli Gómez Rodríguez}}
\fancyhead[LE,RO]{\textcolor{coolgray}{\leftmark}}
\fancyfoot[LE,RO]{\textcolor{coolgray}{\textbf{\thepage}}}

\renewcommand{\headrulewidth}{0.05cm}
\renewcommand{\footrulewidth}{0.01cm}
\newcommand\YUGE{\fontsize{35}{50}\selectfont}

\setlength{\parindent}{0em}
% column space
\setlength{\tabcolsep}{10pt} % Default value: 6pt
% upper and lower padding
\renewcommand{\arraystretch}{1.5} % Default value: 1

\begin{document}

    \pagecolor{coolgray}
    \vspace*{\fill}
        \textcolor{coolpink}{\centerline{\YUGE\textbf{Competitive Programming Reference}}}
        
        \noindent
        \vskip5mm
        \centerline{{\color{coolpink} \rule{200 mm}{1 mm} }}
        \vskip5mm
        
        \textcolor{coolpink}{\centerline{\Huge{Enya Quetzalli Gómez Rodríguez}}}
        
        \vskip35mm
        
        \textcolor{coolpink}{\centerline{\large{eithnegomez@hotmail.com}}}
        \textcolor{coolpink}{\centerline{\large{egomezr}}}
    \vfill
    
    \newpage
    \pagecolor{white}
    \thispagestyle{empty}
    \null
    \newpage
    
    \pagestyle{fancy}
    \newpage
    

\selectfont
    \begin{multicols*}{2}
    \color{coolgray}
        \tableofcontents
        \newpage
        \needspace{7\baselineskip}
\sectionfont{\bfseries\sffamily\centering\Huge}
\vspace{1em}
\section*{abc}
\markboth{ABC}{}
\addcontentsline{toc}{section}{abc}
\vspace{3em}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{abc}
\addcontentsline{toc}{subsection}{abc}
\begin{minted}{cpp}
//Si las constante de math.h no estan definidas

#if defined(_USE_MATH_DEFINES) && !defined(_MATH_DEFINES_DEFINED)
#define _MATH_DEFINES_DEFINED
	#define M_E        2.71828182845904523536	// e
	#define M_LOG2E    1.44269504088896340736	// log2(e)
	#define M_LOG10E   0.434294481903251827651	// log10(e)
	#define M_LN2      0.693147180559945309417	// ln(2)
	#define M_LN10     2.30258509299404568402	// ln(10)
	#define M_PI       3.14159265358979323846	// pi
	#define M_PI_2     1.57079632679489661923	// pi/2
	#define M_PI_4     0.785398163397448309616	// pi/4
	#define M_1_PI     0.318309886183790671538	// 1/pi
	#define M_2_PI     0.636619772367581343076	// 2/pi
	#define M_2_SQRTPI 1.12837916709551257390	// 2/sqrt(pi)
	#define M_SQRT2    1.41421356237309504880	// sqrt(2)
	#define M_SQRT1_2  0.707106781186547524401	// 1/sqrt(2)

#endif

#include <bits/stdc++.h>

using namespace std;

int main(){
	//Para leer de archivos de entrada y salida
	freopen("input.txt", "r", stdin);
	freopen("output.txt", "w", stdout);

	//Entrada y salida rapida de datos en c++
	ios_base::sync_with_stdio(false);
	cin.tie(NULL);

	//Valores Maximos y Minimos de un tipo de dato
	int val_int = std::numeric_limits<int>::max();
	long long int val_lli = std::numeric_limits<long long int>::min();



}

\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{int128}
\addcontentsline{toc}{subsection}{int128}
\begin{minted}{cpp}
#include <iostream>
using namespace std;

typedef __int128 i128;

ostream& operator<<(ostream& dest, __int128_t value){
    ostream::sentry s(dest);
    if(s){
        __uint128_t tmp = value < 0 ? -value : value;
        char buffer[128];
        char* d = std::end(buffer);
        do{
            -- d;
            *d = "0123456789"[ tmp % 10 ];
            tmp /= 10;
        }while(tmp != 0);

        if (value < 0){
            -- d;
            *d = '-';
        }

        int len = end( buffer ) - d;
        if(dest.rdbuf()->sputn( d, len ) != len){
            dest.setstate( ios_base::badbit );
        }
    }
    return dest;
}

int main(){
	i128 a = 1ll;
	for( int i = 0; i < 100; i++ ){
		a <<= 1;
	}
	cout << a << endl;

	return 0;
}
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{template}
\addcontentsline{toc}{subsection}{template}
\begin{minted}{cpp}
#include <bits/stdc++.h>

using namespace std;

typedef long long int lli;

#define vari(v) int v; cin >> v;
#define varl(v) lli v; cin >> v;
#define v(i) vector<int> i;
#define vn(i,n) vector<int> i(n);
#define readv(v) for(auto &x:v) cin >> x;
#define printv(v) for(auto x:v) cout << x << " "; cout << endl;


int main(){
	vari(n)
	vn(nums,n)
	readv(nums);

	printv(nums);

	return 0;
}

\end{minted}

\needspace{7\baselineskip}
\sectionfont{\bfseries\sffamily\centering\Huge}
\vspace{1em}
\section*{estructura de datos}
\markboth{ESTRUCTURA DE DATOS}{}
\addcontentsline{toc}{section}{estructura de datos}
\vspace{3em}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{segment tree}
\addcontentsline{toc}{subsection}{segment tree}
\begin{minted}{cpp}
struct SegmentTree {
	Node *stree;

	SegmentTree(int N){ //Tamaño de arreglo original
		stree = new Node[getSegmentTreeSize(N)];
		buildTree(1, 0, N - 1);
	}

	void buildTree(int nodo, int L, int R){
		if(L == R)
			stree[nodo].make_Node(arr[L]);
		else{
			int mid = (L + R)/2;
			int leftIdx = 2*nodo;
			int rightIdx = 2*nodo + 1;

			buildTree(leftIdx, L, mid);
			buildTree(rightIdx, mid+1, R);

			stree[nodo].merge(stree[leftIdx],tree[rightIdx]);
		}
	}

	Node query(int nodo, int L, int R, int i, int j){
		if(L >= i && R <= j)
			return stree[nodo];
		int mid = (L + R)/2;
		int leftIdx = 2*nodo;
		int rightIdx = 2*nodo + 1;

		if (j <= mid)
			return query(leftIdx, L, mid, i, j);
		if (i > mid)
			return query(rightIdx, mid+1, R, i, j);

		Node leftResult = query(leftIdx, L, mid, i, mid);
		Node rightResult = query(rightIdx, mid+1, R, mid+1, j);

		Node result;
		result.merge(leftResult, rightResult);
		return result;
	}

	void update(int nodo, int L, int R, int idx, int value){
		if(L == R){
			arr[idx] = value;
			stree[nodo].make_Node(value);
			return;
		}

		int mid = (L + R)/2;
		int leftIdx = 2*nodo;
		int rightIdx = 2*nodo + 1;

		if(idx <= mid)
			update(leftIdx, L, mid, idx, value);
		else
			update(rightIdx, mid+1, R, idx, value);
			stree[nodo].merge(stree[leftIdx], stree[rightIdx]);
	}

	int getSegmentTreeSize(int N){
		int size = 1;
		for(; size < N; size <<= 1);
			return size << 1;
	}
};

\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{segment tree dynamic}
\addcontentsline{toc}{subsection}{segment tree dynamic}
\begin{minted}{cpp}
#include <bits/stdc++.h>
#define endl '\n'

using namespace std;

struct node {
  int from, to;
  long long value, lazy;
  node *left, *right;
  node() {
    from=1;
    to=1e5;
    value=0;
    lazy=0;
    left=NULL;
    right=NULL;
  }
  void extend() {
    if(left==NULL) {
      left=new node();
      right=new node();
      left->from=from;
      left->to=(from+to)>>1;
      right->from=((from+to)>>1)+1;
      right->to=to;
    }
  }
};
 
node *root;
int tests,n,queries;
 
void update_tree(node *curr, int left, int right, long long value) {
  if(curr->lazy) {
    curr->value+=(curr->to-curr->from+1)*curr->lazy;
    if(curr->from!=curr->to) {
      curr->extend();
      curr->left->lazy+=curr->lazy;
      curr->right->lazy+=curr->lazy;
    }
    curr->lazy=0;
  }
  if((curr->from)>(curr->to) || (curr->from)>right || (curr->to)<left) return;
  if(curr->from>=left && curr->to<=right) {
    curr->value+=(curr->to-curr->from+1)*value;
    if(curr->from!=curr->to) {
      curr->extend();
      curr->left->lazy+=value;
      curr->right->lazy+=value;
    }
    return;
  }
  curr->extend();
  update_tree(curr->left,left,right,value);
  update_tree(curr->right,left,right,value);
  curr->value=curr->left->value + curr->right->value;
}
 
long long query_tree(node *curr, int left, int right) {
  if((curr->from)>(curr->to) || (curr->from)>right || (curr->to)<left) return 0;
  if(curr->lazy) {
    curr->value+=(curr->to-curr->from+1)*curr->lazy;
    curr->extend();
    curr->left->lazy+=curr->lazy;
    curr->right->lazy+=curr->lazy;
    curr->lazy=0;
  }
  if(curr->from>=left && curr->to<=right) return curr->value;
  long long q1,q2;
  curr->extend();
  q1=query_tree(curr->left,left,right);
  q2=query_tree(curr->right,left,right);
  return q1+q2;
}
 
int main() {
  //ios_base::sync_with_stdio(false);
  //cin.tie(NULL);
  //freopen("test.txt","r",stdin);
  //freopen("taskname.in","r",stdin);
  //freopen("taskname.out","w",stdout);
  int type,p,q;
  long long v;
  int i;
 
  scanf("%d", &tests);
  while(tests--) {
    root=new node();
    scanf("%d %d", &n, &queries);
    for(i=1;i<=queries;i++) {
      scanf("%d", &type);
      if(type==0) {
        scanf("%d %d %lld", &p, &q, &v);
        if(p>q) swap(p,q);
        update_tree(root,p,q,v);
      } 
      else {
        scanf("%d %d", &p, &q);
        if(p>q) swap(p,q);
        printf("%lld\n", query_tree(root,p,q));
      }
    }
  }
 
  return 0;
}

\end{minted}

\needspace{7\baselineskip}
\sectionfont{\bfseries\sffamily\centering\Huge}
\vspace{1em}
\section*{geometria}
\markboth{GEOMETRIA}{}
\addcontentsline{toc}{section}{geometria}
\vspace{3em}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{kruskal}
\addcontentsline{toc}{subsection}{kruskal}
\begin{minted}{cpp}
#include <utility>
#include <algorithm>

typedef pair<int,int> ii;
typedef pair<int, ii> arista;

//Necesita de Union Find

int kruskal(int v, vector <arista> &aristas){
	//Funciona con caminos negativos
	int origen, destino, peso, total=0;

	UnionFind mst(v);
	sort(aristas.begin(), aristas.end());
	for(int i=0; i<aristas.size(); i++){
		peso = aristas[i].first;
		origen = aristas[i].second.first;
		destino = aristas[i].second.second;
		if(!mst.isSameSet(origen, destino)){
			total += peso;
			mst.unionSet(origen,destino);
		}
	}

	return total; //Peso del camino minimo
}



\end{minted}

\needspace{7\baselineskip}
\sectionfont{\bfseries\sffamily\centering\Huge}
\vspace{1em}
\section*{grafos}
\markboth{GRAFOS}{}
\addcontentsline{toc}{section}{grafos}
\vspace{3em}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{hopcroft karp}
\addcontentsline{toc}{subsection}{hopcroft karp}
\begin{minted}{cpp}
#include <algorithm>
#include <queue>
#include <vector>
#include <iostream>

using namespace std;

const int MAXN = 4010;
std::vector<int> adj[MAXN];
std::vector<bool> used(MAXN), visit(MAXN);
int match[MAXN], dist[MAXN];

void bfs(int n1, int n2) {
  std::fill(dist, dist + n1, -1);
  std::queue<int> q;
  for (int u = 0; u < n1; u++) {
    if (!used[u]) {
      q.push(u);
      dist[u] = 0;
    }
  }
  while (!q.empty()) {
    int u = q.front();
    q.pop();
    for (int j = 0; j < (int)adj[u].size(); j++) {
      int v = match[adj[u][j]];
      if (v >= 0 && dist[v] < 0) {
        dist[v] = dist[u] + 1;
        q.push(v);
      }
    }
  }
}

bool dfs(int u) {
  visit[u] = true;
  for (int j = 0; j < (int)adj[u].size(); j++) {
    int v = match[adj[u][j]];
    if (v < 0 || (!visit[v] && dist[v] == dist[u] + 1 && dfs(v))) {
      match[adj[u][j]] = u;
      used[u] = true;
      return true;
    }
  }
  return false;
}

int hopcroft_karp(int n1, int n2) {
  std::fill(match, match + n2, -1);
  std::fill(used.begin(), used.end(), false);
  int res = 0;
  for (;;) {
    bfs(n1, n2);
    std::fill(visit.begin(), visit.end(), false);
    int f = 0;
    for (int u = 0; u < n1; u++) {
      if (!used[u] && dfs(u)) {
        f++;
      }
    }
    if (f == 0) {
      return res;
    }
    res += f;
  }
  return res;
}

int main() {
  int n1 = 3, n2 = 4;
  adj[0].push_back(1);
  adj[1].push_back(0);
  adj[1].push_back(1);
  adj[1].push_back(2);
  adj[2].push_back(2);
  adj[2].push_back(3);
  cout << "Matched " << hopcroft_karp(n1, n2) << " pair(s):" << endl;
  for (int i = 0; i < n2; i++) {
    if (match[i] != -1) {
      cout << match[i] << " " << i << endl;
    }
  }
  return 0;
}
\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{lca}
\addcontentsline{toc}{subsection}{lca}
\begin{minted}{cpp}
//Lowest Common Ancestor

#define maxn 100000

struct node{
	int val;
	int lvl;
	int padres[log2(maxn)];
}node;

*nodo emparejar(*nodo n1, *nodo n2){
	int dif = n1->lvl - n2->lvl;
	int k = log2(dif)+1;
	for(int i=1; i<=k; i=<<1){
		if(i&dif){
			n2 = n2->padres[i];
		}
	}
	return n2;
}

*nodo lca(*nodo n1, *nodo n2){
	n1 = emparejar(n1,n2);
	if(n1 == n2)
		return n1;
	int k = log2(maxn);
	for(int i=1; i<k; i++){
		if(n1->padres[i] == n2->padreS[i])
			return lca(n1->padres[i-1], n2->padres[i-1]);
	}
}



\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{stl tuple}
\addcontentsline{toc}{subsection}{stl tuple}
\begin{minted}{cpp}
#include <tuple>

using namespace std;

int main(){
	tuple<int,string,double,long long int> t;

	//Asignando otra tupla
	t = make_tuple(1,"tupla",23.4927,-243243);
	//Obteniendo un valor de tupla
	int t_int = get<1>(t); //get< index > (tupla)
	//Asingnando un valor a un elemento de la tupla
	get<2>(t) = "tuple";


	return 0;
}

\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{tree diameter}
\addcontentsline{toc}{subsection}{tree diameter}
\begin{minted}{cpp}
#include <vector>
#include <queue>
#include <cstring>

int diameter[500010];

int bfs(int pos, vector< vector<int> > &graph){
	queue<int> q;
	vector<bool> visited(graph.size(),false);

	q.push(pos);
	visited[pos] = 1;

	int maxDist = 0, maxNode=-1;

	while(!q.empty()){
		int u = q.front();
		q.pop();

		if(diameter[u]>maxDist){
			maxDist=diameter[u];
			maxNode=u;
		}
		for(auto i:graph[u]){
			if(!visited[i]){
				visited[i] = true;
				diameter[i] += diameter[u]+1;
				q.push(i);
			}
		}
	}

	return maxNode;
}


int treeDiameter(vector< vector<int> > &graph){
	memset(diameter, 0, sizeof(diameter));
	int extreme1 = bfs(0, graph);
	memset(diameter, 0, sizeof(diameter));
	int extreme2 = bfs(extreme1, graph);

	return diameter[extreme2];
}

\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{union find}
\addcontentsline{toc}{subsection}{union find}
\begin{minted}{cpp}
#include <iostream>

using namespace std;

//Tambien conocido como Disjoin Sets
struct UnionFind{
	int numSets, *padres, *numVer;

	UnionFind(int N) : numSets(N){//Numero de nodos
		padres = new int[N + 1];
		numVer = new int[N + 1];
		for(int i=0; i<=N; i++){
			padres[i] = i;
			numVer[i] = 1;
		}
	}

	int findSet(int x){
		if(x == padres[x])
			return x;
		return (padres[x] = findSet(padres[x]));
	}

	bool isSameSet(int x, int y){
		return findSet(x) == findSet(y);
	}

	void unionSet(int x, int y){
		int xRoot = findSet(x);
		int yRoot = findSet(y);
		if(!isSameSet(xRoot, yRoot)){
			numVer[yRoot] += numVer[xRoot];
			padres[xRoot] = yRoot;
			numSets--;
		}
	}

	int sizeOfSet(int x){
		return numVer[findSet(x)];
	}
};

\end{minted}

\needspace{7\baselineskip}
\sectionfont{\bfseries\sffamily\centering\Huge}
\vspace{1em}
\section*{matematicas}
\markboth{MATEMATICAS}{}
\addcontentsline{toc}{section}{matematicas}
\vspace{3em}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{comb2}
\addcontentsline{toc}{subsection}{comb2}
\begin{minted}{cpp}
#include <iostream>
#include <cstring>

using namespace std;
typedef long long int lli;

//nC2 con triangulo de pascal

lli c2[1000010];
lli mxN = 2;
lli comb2(lli n){
	c2[0] = 0;
	c2[1] = 0;
	c2[2] = 1;
	if(c2[n] != -1)
		return c2[n];
	for(lli i=mxN; i<n; i++){
		c2[i+1] = c2[i] + i;
	}
	mxN = n;
	return c2[n];
}

int main(){
	memset(c2,-1,1000010);

	cout << comb2(4) << endl;
	cout << comb2(6) << endl;
	cout << comb2(19) << endl;
}

\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{comb no prime}
\addcontentsline{toc}{subsection}{comb no prime}
\begin{minted}{cpp}
#include <cmath>

using namespace std;

typedef long long int lli;

lli inv(lli b, lli M){
	lli u = 1, x = 0, s = b, t = M;
	while (s){
		lli q = t/s;
		swap(x -= u * q, u);
		swap(t -= s * q, s);
	}
	return (x %= M) >= 0 ? x : x + M;
}

lli pow(lli a, lli b, lli M){
	lli x = 1;
	for (; b > 0; b >>= 1)
	{
		if (b & 1)
			x = (a * x) % M;
		a = (a * a) % M;
	}
	return x;
}

lli c1(lli n, lli p, lli pk){
	if(n == 0)
		return 1;
	
	lli i, k, ans = 1;
	for(i = n%pk, i = 2; i <= k; i++){
		if(i%p)
			ans = ans*i%pk;
	}
	
	ans = pow(ans, n/pk, pk);
	
	for(k = n%pk, i=2; i <= k; i++){
		if(i%p)
			ans = ans*i%pk;
	}
	
	return ans*c1(n/p, p, pk)%pk;
}

lli cal(lli n, lli m, lli p, lli pi, lli pk){
	lli i, k=0, a, b, c, ans;
	
	a = c1(n, pi, pk);
	b = c1(m, pi, pk);
	c = c1(n-m, pi, pk);
	
	 for(i=n; i; i/=pi)
		 k += i/pi;
	 for(i=m; i; i/=pi)
		 k -= i/pi;
	 for(i=n-m; i; i/=pi)
		 k -= i/pi;
	 
	 ans = a*inv(b,pk)%pk * inv(c,pk)%pk * pow(p,k,pk)%pk;
	 return ans*(p/pk)%p * inv(p/pk, pk)%p;
}

lli comb(lli n, lli m, lli p){ //nCm %p
	lli ans=0, x,i,k;
	for(x = p, i=2; x>1; i++){
		if(x%i == 0){
			for(k=1; x%i == 0; x/=i)
				k *= i;
			ans = (ans + cal(n, m, p, i, k))%p;
		}
	}
	
	return ans;
}

\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{comb prime mod}
\addcontentsline{toc}{subsection}{comb prime mod}
\begin{minted}{cpp}
//nCk n<=10^5

#include <iostream>

using namespace std;

typedef long long int lli;

lli fact[100005];

void calcFact(lli M){ //Factorial Modulo M
	fact[0] = 1;
	for(lli i=1; i<100001; i++){
		fact[i] = (fact[i-1] * (i%M))%M;
	}
	return;
}

lli inv(lli b, lli M){
	lli u = 1, x = 0, s = b, t = M;
	while(s){
		lli q = t/s;
		swap(x -= u * q, u);
		swap(t -= s * q, s);
	}
	return (x %= M) >= 0 ? x : x + M;
}

lli combinatoria(lli n, lli k, lli M){ //nCk % M
	lli denom = (fact[k] * fact[n-k])%M;
	return (fact[n] * inv(denom,M))%M;
}

int main(){
	//M Tiene que ser primo para que tenga inverso modular. 
	calcFact(986444689);
	cout << combinatoria(9,3,986444689) << endl;
	
	return 0;
}

\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{newton raphson}
\addcontentsline{toc}{subsection}{newton raphson}
\begin{minted}{cpp}
#include <iostream>

using namespace std;

double f(double x){
	double ans;

	//ans = x*x*x-x-1.0;

	return ans;
}

double f_p1(double x){ //Primera derivada de x
	double ans;

	//ans = 3.0*x*x-1.0;

	return ans;
}

double newton_raphson(int it, double sol_prev){
	if(it == 100) //100 iteracion de aproximacion
		return sol_prev;

	double new_sol = sol_prev - (f(sol_prev)/f_p1(sol_prev));
	return newton_raphson(it+1, new_sol);
}

int main(){

	cout << newton_raphson(1, 1.0) << endl;

}

\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{prime factors}
\addcontentsline{toc}{subsection}{prime factors}
\begin{minted}{cpp}
#include <map>
#include <cmath>

map<lli,lli>  primeFactors(lli n){
    map<lli,lli> primeFrec;
    
    while(!(n&1)){ 
    	primeFrec[2]++;
        n = n/2; 
    } 

    lli sq = sqrt(n);
    for(lli i = 3; i <= sq+2; i += 2){ 
        while (n%i == 0){
        	primeFrec[i]++; 
            n = n/i; 
        } 
    } 

    if(n > 2)
    	primeFrec[n]++; 
    
    return primeFrec;
}

\end{minted}

\needspace{3\baselineskip}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{suma}
\addcontentsline{toc}{subsection}{suma}
\begin{minted}{cpp}
lli suma(lli a, lli b){
	return a+b;
}

\end{minted}

\needspace{7\baselineskip}
\sectionfont{\bfseries\sffamily\centering\Huge}
\vspace{1em}
\section*{Miguel}
\markboth{MIGUEL}{}
\addcontentsline{toc}{section}{Miguel}
\vspace{3em}
\subsectionfont{\large\bfseries\sffamily\underline}
\subsection*{EstilosMiguel}
\addcontentsline{toc}{subsection}{EstilosMiguel}
\begin{minted}{cpp}
algo aqui

\end{minted}


    \end{multicols*}
    
    \newpage
    \thispagestyle{empty}
    \textcolor{coolgray}{\centerline{\Huge\textbf{Competitive Programming Reference}}}
    \vskip5mm
    \textcolor{coolgray}{\centerline{\large{\textbf{Created by:} Enya Quetzalli Gómez Rodríguez}}}
    \vskip1mm
    \textcolor{coolgray}{\centerline{\large{\textbf{Created with:} mkcpr reference}}}
    \vskip1mm
    \textcolor{coolgray}{\centerline{\large{\textbf{Created on:} March 30, 2020}}}
    \vskip1mm
    \textcolor{coolgray}{\centerline{\large{\textbf{Last Update:} \today}}}
    \vskip10mm

    \begin{center}
        \textcolor{coolgray}{\center{\large{\textbf{I met the competitive programming at my university "The Superior School of Computer Sciences of the National Polytechnic Institute", thanks to a club within the school called "algorithmic club", where I met ICPC and loved competitive programming, this group of people at I belong has offered me everything I know now, we always pass all our knowledge to the following generations, and we all contribute to our community to achieve more and more. I will always be grateful to this group of people who changed my life}}}}
    \end{center}
    
    \vskip10mm
    
     \textcolor{coolgray}{\centerline{\large{\textbf{Special thanks:}}}}
     
     \centering
     \includegraphics[width=4cm, height=4cm]{logo_huron_circular}
     
     
\end{document}
